# JavaScript闭包(讲给新来的女实习生)


撩妹守则第一条，女孩子都喜欢童话故事。

那就先来讲一个童话故事~

<!--more-->



```javascript
// 有一个公主
// 她生活在一个充满冒险的奇妙世界里
// 她遇见了她的白马王子，带着她骑着独角兽环游世界
// 与龙搏斗，遇到了会说话的松鼠，以及许多其他幻想的事情。
function princess () {
    var adventrures = [];
    function princeCharming () {};
    var unicorn = {};
    var dragons = [];
    var squirrel = "Hello!";
    // 但她不得不回到她那充满家务和大人们的单调世界。
    return {
    // 她经常给身边的人讲她作为一个公主的奇妙经历。
      story:function () {
          return adventures[adventures.length - 1];
      }
    }
}
// 但他们看到的只是一个小女孩在讲述关于魔法和幻想的故事
var littleGril = princess();
littleGril.story();
// 即使大人们知道她是真正的公主，他们也不会相信所谓的独角兽或龙，因为他们永远看不到它们
// 大人们说它们只存在于小女孩的想象中
// 但我们知道真正的真理
// 里面的小女孩真的是个公主
```

这个故事来自于[stackoverflow的一则回答](https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/111111#111111)，看不懂没关系，等阅读完本文后，回头再来看这个故事，你会发现你已经完全了解了我的魅力，咳咳@¥%#…………`JavaScript`中闭包的魅力。


## 什么是闭包？
`当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。    --- 你不知道的JavaScript(上卷)`

来个🌰

```javascript
function demo() {
    var a = 1;
    return function () {
        return a; 
    }
}

var a = demo();
console.log(a());  // 1
```
### 闭包的构成

闭包由两部分构成：**函数，以及创建该函数的环境。**

环境由闭包创建时在作用域中的任何局部变量组成。

### 闭包的本质

**闭包其实是`JavaScript`函数作用域的副作用产品。**

**闭包是一种特殊的对象。**

所谓`有意栽花花不开,无心插柳柳成荫`，不是`JavaScript`故意要使用闭包，而是由于`JavaScript`的函数内部可以使用函数外部的变量，这段代码又**刚刚好**符合闭包的定义。

在`JavaScript`中，外部函数调用之后其变量对象本应该被销毁，但闭包阻止了它们的销毁，我们仍然可以访问外部函数的变量对象。

进一步的说，通常情况下，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，如果创建了一个闭包的话，这个函数的作用域就会一直保存到闭包不存在为止。

```javascript
function addCalculator (x) {
    return function (y) {
        return x + y;
    }
}

var add1 = addCalculator(1);

console.log(add1(1)); //2

// 释放对闭包的引用
add1 = null;

console.log(add1(1)); //Uncaught TypeError: add1 is not a function

```

### 闭包的应用
我们可以用闭包来做什么呢？

了解`Java`的同学可能知道，`Java`是支持私有方法的，私有方法只能被一个类中的其他方法所调用，但是`JavaScript`没有提供这种原生支持，所以我们可以通过闭包来模拟私有方法。

私有方法自然有私有方法的好处，私有方法有利于限制对代码的访问，而且可以避免非核心的方法干扰代码的公共接口，减少全局污染。

来个🌰

```javascript
var calculator = (function(){
    var a = 1;
    function addCalculator(val){
        a += val
    }
    return {
        add1:function() {
            addCalculator(1);
        },
        add2:function() {
            addCalculator(2);
        },
        result:function() {
            return a
        }
    }
})();

console.log(calculator.result());  // 1
calculator.add1();
console.log(calculator.result());  // 2
calculator.add2();
console.log(calculator.result());  // 4
```

上面这种方式也叫做**模块模式(module pattern)**。


### 使用闭包的注意事项

#### 内存泄漏

因为闭包可以使函数中的变量都保存在内存中，造成很大的内存消耗，所以如果 不是某些特定的任务需要使用闭包，我们不要滥用它。

很多博客中都提到了这一点，但是其实都是不完全对的。

**敲黑板！！！**

使用不当的闭包会在`IE(IE9)`之前造成内存泄漏问题。因为它的`JavaScript`引擎使用的垃圾回收算法是引用计数法，对于循环引用将会导致`GC`(下文会介绍)无法回收垃圾。

关于各个浏览器的闭包测试，详情请见[司徒正美-js闭包测试](https://www.cnblogs.com/rubylouvre/p/3345294.html)

## 垃圾回收机制
都9102年了，全国开始实行垃圾分类了，你居然还不知道垃圾回收机制，赶快来补习一下！

垃圾回收也就是`GC(Garbage Collection)`。

`GC`把程序不用的内存空间视为垃圾，找到它们并且将它们回收，让程序员可以再次利用这部分空间。

不是所有的语言都有`GC`，一般存在于高级语言中，如`Java`、`JavaScript`、`Python`。那么在没有`GC`的世界里，程序员就比较辛苦，只能手动去管理内存，比如在`C`语言中我们可以通过`malloc/free`，在`C++`中的`new/delete`来进行管理。


## 垃圾回收算法
因为这一部分的内容很多，本文只进行简单的讲解，如果想深入了解垃圾回收算法的同学可以在文末获取学习资料。
### GC标记-清除算法
世界上首个值得纪念的`GC`算法是`GC标记-清除算法`。因为自其问世以来，一直到半个世纪后的今天，它依然是各种处理程序所用的伟大的算法。

`GC标记-清除算法`由标记阶段和清除阶段构成，标记阶段将所有的活动对象做上相应的标记，清除阶段把那些没有标记的对象，也就是非活动对象进行回收。在搜索对象并进行标记的时候使用了深度优先搜索，尽可能的从深度上搜索树形结构。

优点：

> 1.算法简单，实现容易。
>
> 2.与保守式的GC算法兼容。

缺点：

> 1.在使用过程中会出现碎片化的情况，如同`Windows`的文件系统一样，导致
> 无数的小分块散布在堆的各个地方。
>
> 2.分配速度，由于分块的不连续性，算法每次分配的时候都需要遍历空闲链表为了找到足够大的分块，这样最糟糕的情况就是遍历到最后才找到合适的分
> 块，影响了分配速度。


### 引用计数法

这种方法中引入了计数器的概念，通过计数器来表示对象的“人气指数”，也就是有多少个程序引用了这个对象。当计数器(引用数)为0时，垃圾立刻被回收。

优点:

> 1.可以立即回收垃圾。
>
> 2.最大暂停的时间短。
>
> 3.并且没有必要沿指针查找。

缺点:
> 1.上文提到过的循环引用无法回收。
>
> 2.并且实现起来很复杂。
>
> 3.计数器值的增减处理十分繁重。
>
> 4.同时计数器需要占很多位，导致内存空间的使用效率大大降低。


**软件工程没有银弹**，这些缺点也都有相应的办法进行解决，如果你想深入了解垃圾回收算法，可以购买[垃圾回收的算法与实现](https://book.douban.com/subject/26821357/)这本书去看，建议支持正版。




